# Liskov substitution Principle


Let q(x) be a property provable about objects of x of type T. Then q(y) should be provable for objects y of type S where S is a subtype of T. |                                                                                                    
--------------------------------------------------------------------------------------------------------------------------------------------- |

> Необходимо, чтобы подклассы могли бы служить заменой для своих суперклассов.

Цель этого принципа заключаются в том, чтобы классы-наследники могли бы использоваться вместо родительских классов, от 
которых они образованы, не нарушая работу программы. Если оказывается, что в коде проверяется тип класса, значит 
принцип подстановки нарушается.

Рассмотрим применение этого принципа, вернувшись к примеру с классом *`Animal`*. Напишем функцию, предназначенную для 
возврата информации о количествах конечностей животного.

```typescript
function AnimalLegCount(a: Array<Animal>) {
  for(let i = 0; i <= a.length; i++) {
      if(typeof a[i] === Lion) {
          return LionLegCount (a[i]);
      }
      if(typeof a[i] === Mouse) {
          return MouseLegCount (a[i]);
      }
      if(typeof a[i] === Snake) {
                return SnakeLegCount (a[i]);
            }
  }
}

AnimalLegCount(animals);
```

Функция нарушает принцип подстановки (и принцип открытости-закрытости). Этот код должен знать о типах всех 
обрабатываемых им объектов и, в зависимости от типа, обращаться к соответствующей функции для подсчёта конечностей 
конкретного животного. Как результат, при создании нового типа животного функцию придётся переписывать:

```typescript
class Pigeon extends Animal {}

const animals: Array<Animal> = [
    new Pigeon()
];

function AnimalLegCount(a: Array<Animal>) {
  for(let i = 0; i <= a.length; i++) {
        if(typeof a[i] === Lion) {
            return LionLegCount (a[i]);
        }
        if(typeof a[i] === Mouse) {
            return MouseLegCount (a[i]);
        }
        if(typeof a[i] === Snake) {
            return SnakeLegCount (a[i]);
        }
        if(typeof a[i] === Pigeon) {
            return PigeonLegCount (a[i]);
        }
  }
}

AnimalLegCount(animals);
```

Для того чтобы эта функция не нарушала принцип подстановки, преобразуем её с использованием требований, 
сформулированных **Стивом Фентоном**. Они заключаются в том, что методы, принимающие или возвращающие значения с типом 
некоего суперкласса (*`Animal`* в нашем случае) должны также принимать и возвращать значения, типами которых являются 
его подклассы (*`Pigeon`*).

Вооружившись этими соображениями мы можем переделать функцию *`AnimalLegCount`*:

```typescript
function AnimalLegCount(a: Array<Animal>) {
  for(let i = 0; i <= a.length; i++) {
        a[i].LegCount();
  }
}

AnimalLegCount(animals);
```

Теперь эта функция не интересуется типами передаваемых ей объектов. Она просто вызывает их методы *`LegCount`*. Всё, 
что она знает о типах — это то, что обрабатываемые ей объекты должны принадлежать классу *`Animal`* или его подклассам.

Теперь в классе Animal должен появиться метод *`LegCount`* :

```typescript
class Animal  {
    LegCount(){};
}
```

А его подклассам нужно реализовать этот метод:

```typescript
class Lion extends Animal {
    LegCount(){};
}
```

В результате, например, при обращении к методу *`LegCount`* для экземпляра класса *`Lion`* производится вызов метода, 
реализованного в этом классе, и возвращается именно то, что можно ожидать от вызова подобного метода.

Теперь функции *`AnimalLegCount`* не нужно знать о том, объект какого именно подкласса класса *`Animal`* она 
обрабатывает для того, чтобы узнать сведения о количестве конечностей у животного, представленного этим объектом. 
Функция просто вызывает метод *`LegCount`* класса *`Animal`*, так как подклассы этого класса должны реализовывать этот 
метод для того, чтобы их можно было бы использовать вместо него, не нарушая правильность работы программы.
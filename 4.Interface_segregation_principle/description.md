# Interface segregation Principle

A client should never be forced to implement an interface that it doesn't use or clients shouldn't be forced to depend on methods they do not use. |
-------------------------------------------------------------------------------------------------------------------------------------------------- |

> Создавайте узкоспециализированные интерфейсы, предназначенные для конкретного клиента. Клиенты не должны зависеть от интерфейсов, которые они не используют.

Этот принцип направлен на устранение недостатков, связанных с реализацией больших интерфейсов.

Рассмотрим интерфейс *`Shape`*:

```typescript
interface Sharpe {
  drawCircle();
  drawSquare();
  drawRectangle();
}
```

Он описывает методы для рисования кругов (*`drawCircle`*), квадратов (*`drawSquare`*) и прямоугольников 
(*`drawRectangle`*). В результате классы, реализующие этот интерфейс и представляющие отдельные геометрические фигуры, 
такие, как круг (*`Circle`*), квадрат (*`Square`*) и прямоугольник (*`Rectangle`*), должны содержать реализацию всех 
этих методов. Выглядит это так:

```typescript
class Circle implements Sharpe {
    drawCircle() {};
    drawSquare() {};
    drawRectangle() {};
}

class Square implements Sharpe {
    drawCircle() {};
    drawSquare() {};
    drawRectangle() {};
}

class Rectangle implements Sharpe {
    drawCircle() {};
    drawSquare() {};
    drawRectangle() {};
}
```

Странный у нас получился код. Например, класс *`Rectangle`*, представляющий прямоугольник, реализует методы 
(*`drawCircle`* и *`drawSquare`*), которые ему совершенно не нужны. То же самое можно заметить и при анализе кода двух 
других классов.

Предположим, мы решим добавить в интерфейс Shape ещё один метод, *`drawTriangle`*, предназначенный для рисования 
треугольников:

```typescript
interface Sharpe {
  drawCircle();
  drawSquare();
  drawRectangle();
  drawTriangle();
}
```

Это приведёт к тому, что классам, представляющим конкретные геометрические фигуры, придётся реализовывать ещё и метод 
*`drawTriangle`*. В противном случае возникнет ошибка.

Как видно, при таком подходе невозможно создать класс, который реализует метод для вывода круга, но не реализует методы 
для вывода квадрата, прямоугольника и треугольника. Такие методы можно реализовать так, чтобы при их выводе 
выбрасывалась бы ошибка, указывающая на то, что подобную операцию выполнить невозможно.

Принцип разделения интерфейса предостерегает нас от создания интерфейсов, подобных *`Shape`* из нашего примера. Клиенты 
(у нас это классы *`Circle`*, *`Square`* и *`Rectangle`*) не должны реализовывать методы, которые им не нужно 
использовать. Кроме того, этот принцип указывает на то, что интерфейс должен решать лишь какую-то одну задачу (в этом 
он похож на принцип единственной ответственности), поэтому всё, что выходит за рамки этой задачи, должно быть вынесено 
в другой интерфейс или интерфейсы.

В нашем же случае интерфейс *`Shape`* решает задачи, для решения которых необходимо создать отдельные интерфейсы. 
Следуя этой идее, переработаем код, создав отдельные интерфейсы для решения различных узкоспециализированных задач:

```typescript
interface Sharpe {
  draw();
}

interface ICircle {
  drawCircle();
}

interface ISquare {
  drawSquare();
}

interface IRectangle {
  drawRectangle();
}

interface ITriangle {
  drawTriangle();
}

class Circle implements ICircle {
    drawCircle() {};
}

class Square implements ISquare {
    drawSquare() {};
}

class Rectangle implements IRectangle {
    drawRectangle() {};
}

class Triangle implements ITriangle {
    drawTriangle() {};
}

class CustomSharpe implements Sharpe {
    draw() {}
}
```

Теперь интерфейс *`ICircle`* используется лишь для рисования кругов, равно как и другие специализированные интерфейсы — 
для рисования других фигур. Интерфейс *`Shape`* может применяться в качестве универсального интерфейса.